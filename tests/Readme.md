##Тестирование

1. Добавить в artisan команду/класс \Parcsis\ConsumersMQ\Tests\FunctionalTest
2. Необходимо запустить 4 тестовый консьюмера:
	* \Parcsis\ConsumersMQ\Tests\InsertIn (комманда `php artisan consumer-mq:test insert_in`)
	* \Parcsis\ConsumersMQ\Tests\CalculateEven (комманда `php artisan consumer-mq:test calculate_even`)
	* \Parcsis\ConsumersMQ\Tests\CalculateOdd (комманда `php artisan consumer-mq:test calculate_odd`)
	* \Parcsis\ConsumersMQ\Tests\CalculateOther (комманда `php artisan consumer-mq:test calculate_other`)

3. Необходимо создать таблицы (выбрать любую удобную тестовую БД) для записи хода тестирования:

	`php artisan migrate --bench="parcsis/consumers-mq"`

4. Запуск процедуры тестирования:

	`php artisan consumer-mq:test insert`


###Схема тестирования.

* В таблицу calculated добавляется 1000 случайных чисел (константа количества чисел FunctionalTest::POINTS) от 1 до POINTS
* Для каждого числа создается событие (FunctionalTest::INSERT_QUEUE) в тестовый обменник (обменник в константе FunctionalTest::EXCHANGE)
* Добавление в базу осуществляется консьюмером InsertIn. Консьюмер обрабатывает ровно POINTS сообщений, что задано в его параметрах и вырубается
* После добавления формируются события добавления чисел, отдельно для четных и нечетных - для 2х соответствующих консьюмеров
* Затем каждое четное число, кроме делящихся на 4, обрабатываются консьюмером CalculateEven, а нечетное (кроме делящихся на 3) - CalculateOdd
* Числа, делящиеся на 3 и 4 - обрабатываются консьюмером CalculateOther
* Пока консьюмеры перемалывают числа, команда `artisan consumer-mq:test insert` в цикле проверяет таблицу на количество обработанных записей. После того,
как в таблице не останется ниодной не обработанной (консьюмеры помечают каждую обработанную запись и оставляют описание ошибок) осуществляется выход.
Если есть ошибки - они печаются в консоль.
После окончания работы в любом случае всем консьюмерам посылается магическая константа для завершения работы.

Тест считается пройденным, если
1. Все консьюмеры корректно остановились сами
2. `artisan consumer-mq:test insert` напечатал `Success!`

В ином случае надо анализировать таблицу:
* в колонке in число,
* в колонке out - результат работы консьюмера (0 если не обрабатывался, 1 если корреткно, 2 если с ошибкой)
* в колонке error - описание ошибки (в скобках класс, в котором зафиксировалась ошибка)
* в колонке owner - последний класс консьюмера, который обработал сообщение до того класса, где выстрелила ошибка